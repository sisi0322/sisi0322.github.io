<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>重力4目並べ</title>
  <style>
body {
  font-family: sans-serif;
  text-align: center;
  background: linear-gradient(120deg, #a8c0ff 0%, #f6d365 100%);
}
#controls {
  margin: 0 auto 12px auto;
  text-align: center;
}
#board-area {
  display: flex;
  align-items: flex-end;
  justify-content: center;
  margin-top: 0;
}
#user-area, #com-area {
  width: 130px; min-width: 90px;
  display: flex; flex-direction: column; align-items: center;
}
#avatar-user, #avatar-com { width: 100%; }
.log-box {
  min-height: 72px;
  max-height: 164px;
  width: 96%;
  font-size: 15px;
  background: #f4f7ffcc;
  margin-top: 6px;
  border-radius: 8px;
  padding: 7px 5px 7px 5px;
  box-shadow: 0 1px 6px #0001;
  text-align: left;
  overflow-y: auto;
  border: 1.5px solid #e6e9fb;
}
#game-board table {
  margin: auto;
  border-collapse: collapse;
  background: rgba(255,255,255,0.93);
  border-radius: 12px;
  box-shadow: 0 10px 32px #0003;
}
td {
  width: 50px; height: 50px;
  border: 1.5px solid #3334;
  background-color: #dfe6fa;
  position: relative;
  cursor: pointer;
}
td:hover { background: #ffd85d82; }
td .stone {
  width: 40px; height: 40px;
  border-radius: 50%;
  position: absolute;
  left: 5px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.18);
}
.stone.red   { background-color: #d00; border:2.3px solid #faaa;}
.stone.blue  { background-color: #1e4eb0; border:2.3px solid #9ee;}
@keyframes drop-stone {
  from { top: -70px; }
  to   { top: 5px; }
}
.dropping {
  animation: drop-stone 0.41s cubic-bezier(0.30,0.8,0.18,1.0);
}
#winner-banner {
  font-size: 2.1rem;
  font-weight: bold;
  padding: 22px 0;
  margin: 24px auto 0 auto;
  width: 370px;
  border-radius: 26px;
  background: linear-gradient(80deg,#fffaab 60%,#feec9f 100%);
  color: #b71c1c;
  border: 4px solid #ffb400;
  box-shadow: 0 0 40px #fed70087;
  letter-spacing: 0.13em;
  z-index: 999;
  position: relative;
  display: none;
  transition: 0.4s;
  animation: winner-flash 1.7s ease;
}
@keyframes winner-flash {
  0%   { transform:scale(0.6); opacity:0;}
  14%  { transform:scale(1.05); opacity:1;}
  27%  { transform:scale(1.09);}
  45%  { transform:scale(1);}
  55%  { transform:scale(1.1);}
  65%  { transform:scale(1);}
  100% { opacity:1;}
}
.avatar {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.avatar-icon {
  width: 66px;
  height: 66px;
  border-radius: 50%;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: outline 0.4s;
}
.avatar.user .avatar-icon {
  background: linear-gradient(135deg,#f66,#d00 80%);
  color: #fff;
  font-size: 34px;
  border: 3px solid rgba(220,10,10,0.55);
  box-shadow: 0 2px 8px #9005;
}
.avatar.com .avatar-icon {
  background: linear-gradient(135deg,#7ad3ff 60%,#235eb5 100%);
  color: #fff;
  font-size: 34px;
  border: 3px solid rgba(30,80,200,0.38);
  box-shadow: 0 2px 8px #0075;
}
.avatar.active .avatar-icon {
  outline: 5px solid gold !important;
}
.avatar-name {
  font-weight:bold;
  font-size:17px;
}

#column-buttons {
  margin: 9px auto 0 auto; text-align: center;
}
#column-buttons button {
  font-size: 20px;
  margin: 3px; padding: 8px 10px;
  width: 48px; height: 34px;
  background: #eef3fa;
  border: 1.5px solid #aac4dc;
  border-radius: 7px;
  box-shadow: 0 2px 4px #3989;
  transition: background 0.18s, box-shadow 0.18s;
  cursor: pointer;
}
#column-buttons button:not(:disabled):hover {
  background: #ffd85d;
  box-shadow: 0 2px 12px #ffe06b88;
}
#column-buttons button:disabled {
  opacity: 0.627;
  cursor: not-allowed;
}

/* スマホ対応 */
@media (max-width: 680px) {
  #board-area { flex-direction: column; align-items: center;}
  #user-area, #com-area { width: 100%; min-width: 0; margin-bottom: 12px;}
  #game-board {margin-bottom: 14px;}
  #winner-banner {font-size:1.25rem; width:99vw;}
}
  </style>
</head>
<body>
<h1>重力4目並べ</h1>
<div id="controls"></div>
<div id="board-area">
  <div id="user-area">
    <div id="avatar-user"></div>
    <pre id="log-user" class="log-box"></pre>
  </div>
  <div id="game-board"></div>
  <div id="com-area">
    <div id="avatar-com"></div>
    <pre id="log-com" class="log-box"></pre>
  </div>
</div>
<div id="winner-banner" style="display:none;"></div>
<script>
class Player {
  constructor(name, order) { this.name = name; this.order = order; }
  async put(grid) { throw new Error("Not implemented"); }
  getName() { return this.name; }
  getOrder() { return this.order; }
  getColor() { return this.order === 0 ? "red" : "blue"; }
  getSideID() { return this.order === 0 ? "avatar-user" : "avatar-com"; }
  getLogID() { return this.order === 0 ? "log-user" : "log-com"; }
}
class Man extends Player {
  constructor(name, order, board) { super(name, order); this.board = board; }
  put(grid) {
    return new Promise(resolve => {
      const handler = e => {
        let col = undefined;
        if (e.target.dataset && e.target.dataset.col !== undefined) {
          col = parseInt(e.target.dataset.col);
        } else {
          if (e.target && e.target.tagName === "TD" && e.target.dataset.col !== undefined) {
            col = parseInt(e.target.dataset.col);
          }
        }
        if (!isNaN(col)) {
          this.board.clearColBtnHandlers();
          this.board.clearCellClickHandler();
          resolve(col);
        }
      };
      this.board.setColBtnHandler(handler);
      this.board.setCellClickHandler(handler);
      this.board.enableColBtns(true);
    });
  }
}
class Judge {
  constructor(rows, cols) { this.rows = rows; this.cols = cols; }
  checkWinner(order, row, col, grid) {
    return (
      this.count(order, row, col, 0, 1, grid) + this.count(order, row, col, 0, -1, grid) >= 3 ||
      this.count(order, row, col, 1, 0, grid) >= 3 ||
      this.count(order, row, col, 1, 1, grid) + this.count(order, row, col, -1, -1, grid) >= 3 ||
      this.count(order, row, col, 1, -1, grid) + this.count(order, row, col, -1, 1, grid) >= 3
    );
  }
  count(order, row, col, dr, dc, grid) {
    let cnt = 0;
    for (let i = 1; i <= 3; i++) {
      const r = row + dr * i, c = col + dc * i;
      if (r < 0 || r >= this.rows || c < 0 || c >= this.cols || grid[r][c] !== order) break; cnt++;
    }
    return cnt;
  }
  canPut(col, grid) {
    for (let row = this.rows - 1; row >= 0; row--) {
      if (grid[row][col] === -1) return row;
    }
    return -1;
  }
}
class Board {
  constructor(rows, cols, containerId) {
    this.rows = rows; this.cols = cols;
    this.container = document.getElementById(containerId);
    this.grid = [];
    this.buttons = [];
    this.colBtns = [];
    this.cellHandler = null;
    this.init();
  }
  init() {
    this.container.innerHTML = "";
    this.grid = Array.from({ length: this.rows }, () => Array(this.cols).fill(-1));
    const table = document.createElement("table");
    this.buttons = [];
    for (let row = 0; row < this.rows; row++) {
      const tr = document.createElement("tr"); const btnRow = [];
      for (let col = 0; col < this.cols; col++) {
        const td = document.createElement("td");
        td.dataset.row = row; td.dataset.col = col;
        tr.appendChild(td); btnRow.push(td);
      }
      table.appendChild(tr); this.buttons.push(btnRow);
    }
    this.container.appendChild(table);
    this.renderColButtons();
  }
  renderColButtons() {
    let btnRow = document.getElementById("column-buttons");
    if (!btnRow) {
      btnRow = document.createElement("div");
      btnRow.id = "column-buttons";
      btnRow.style.marginTop = "8px";
      btnRow.style.textAlign = "center";
      this.container.appendChild(btnRow);
    }
    btnRow.innerHTML = "";
    this.colBtns = [];
    for (let i = 0; i < this.cols; i++) {
      const btn = document.createElement("button");
      btn.textContent = (i + 1).toString();
      btn.dataset.col = i;
      btn.disabled = true;
      btnRow.appendChild(btn);
      this.colBtns.push(btn);
    }
  }
  setColBtnHandler(handler) { for (const btn of this.colBtns) btn.onclick = handler; }
  enableColBtns(flag) { for (const btn of this.colBtns) btn.disabled = !flag; }
  clearColBtnHandlers() { for (const btn of this.colBtns) { btn.onclick = null; btn.disabled = true; } }
  setCellClickHandler(handler) {
    this.clearCellClickHandler();
    this.cellHandler = handler;
    for (let row of this.buttons) for (let td of row) {
      td.addEventListener('click', handler);
    }
  }
  clearCellClickHandler() {
    if (!this.cellHandler) return;
    for (let row of this.buttons) for (let td of row) {
      td.removeEventListener('click', this.cellHandler);
    }
    this.cellHandler = null;
  }
  async update(row, col, color) {
    if (this.grid[row][col] !== -1) return;
    let stone = document.createElement("div");
    stone.className = `stone ${color} dropping`;
    stone.style.left = "5px";
    stone.style.top = "-70px";
    this.buttons[row][col].appendChild(stone);
    setTimeout(()=>{
      stone.style.top = "5px";
    }, 5);
    await new Promise(r=>setTimeout(r, 420));
    stone.classList.remove('dropping');
    stone.style.top = "5px";
    this.grid[row][col] = color === "red" ? 0 : 1;
  }
  reset() { this.init(); }
  getGrid() { return this.grid.map(row => row.slice()); }
}
class Recorder {
  constructor(userId, comId) {
    this.userLogs = [];
    this.comLogs = [];
    this.userElem = document.getElementById(userId);
    this.comElem = document.getElementById(comId);
  }
  record(player, col) {
    const log = `列${col + 1}`;
    if(player.getOrder()===0){
      this.userLogs.push(log);
      this.userElem.textContent = this.userLogs.join("\n");
    } else {
      this.comLogs.push(log);
      this.comElem.textContent = this.comLogs.join("\n");
    }
  }
  clear() {
    this.userLogs = [];
    this.comLogs = [];
    this.userElem.textContent = "";
    this.comElem.textContent = "";
  }
}
class Com extends Player {
  constructor(name, order, judge, strategy = "MONTE_CARLO") {
    super(name, order);
    this.judge = judge;
    this.strategy = strategy;
    this.MAX_DEPTH = 4;
    this.MONTE_CARLO_SIMULATIONS = 20;
  }
  getOrder() { return this.order; }
  getOpponentOrder() { return (this.getOrder() === 0) ? 1 : 0; }
  deepCopyGrid(grid) { return grid.map(row => row.slice()); }
  isFull(grid) {
    for(let col=0; col<grid[0].length; col++)
      if(this.judge.canPut(col, grid) !== -1) return false;
    return true;
  }
  getNextOpenRow(grid, col) {
    for(let row=grid.length-1; row>=0; row--){
      if(grid[row][col]==-1) return row;
    }
    return -1;
  }
  getAvailableColumns(grid) {
    let available = [];
    for(let col=0; col<grid[0].length; col++) {
      if(this.judge.canPut(col, grid) !== -1) available.push(col);
    }
    return available;
  }
  prioritizeColumns(availableColumns, totalColumns) {
    const center = Math.floor(totalColumns / 2);
    availableColumns.sort((a, b) => Math.abs(center - a) - Math.abs(center - b));
    const topN = Math.min(3, availableColumns.length);
    const topChoices = availableColumns.slice(0, topN);
    return topChoices[Math.floor(Math.random()*topChoices.length)];
  }
  getMoveOrder(grid) {
    let order = [];
    const center = Math.floor(grid[0].length/2);
    order.push(center);
    let sides = [];
    for(let i=1;i<=center;i++) {
      if(center-i>=0) sides.push(center-i);
      if(center+i<grid[0].length) sides.push(center+i);
    }
    for(let i = sides.length-1; i>0; i--) {
      let j = Math.floor(Math.random()*(i+1));
      [sides[i],sides[j]] = [sides[j],sides[i]];
    }
    order.push(...sides);
    return order;
  }
  evaluateBoard(grid) {
    let score = 0;
    let centerColumn = Math.floor(grid[0].length / 2);
    let centerCount = 0;
    for (let row = 0; row < grid.length; row++) {
      if (grid[row][centerColumn] === this.getOrder()) centerCount++;
    }
    score += centerCount * 3;
    score += this.evaluateLines(grid, this.getOrder());
    score -= this.evaluateLines(grid, this.getOpponentOrder()) * 2;
    return score;
  }
  evaluateLines(grid, player) {
    let score = 0;
    for (let row = 0; row < grid.length; row++) {
      for (let col = 0; col < grid[0].length - 3; col++) {
        let window = [];
        for (let i = 0; i < 4; i++) window.push(grid[row][col + i]);
        score += this.getScoreForWindow(window, player);
      }
    }
    for (let col = 0; col < grid[0].length; col++) {
      for (let row = 0; row < grid.length - 3; row++) {
        let window = [];
        for (let i = 0; i < 4; i++) window.push(grid[row + i][col]);
        score += this.getScoreForWindow(window, player);
      }
    }
    for (let row = 0; row < grid.length - 3; row++) {
      for (let col = 0; col < grid[0].length - 3; col++) {
        let window = [];
        for (let i = 0; i < 4; i++) window.push(grid[row + i][col + i]);
        score += this.getScoreForWindow(window, player);
      }
    }
    for (let row = 0; row < grid.length - 3; row++) {
      for (let col = 3; col < grid[0].length; col++) {
        let window = [];
        for (let i = 0; i < 4; i++) window.push(grid[row + i][col - i]);
        score += this.getScoreForWindow(window, player);
      }
    }
    return score;
  }
  getScoreForWindow(window, player) {
    let score = 0;
    const opponent = this.getOpponentOrder();
    let playerCount = 0, empty = 0, opponentCount = 0;
    for (let cell of window) {
      if (cell === player) playerCount++;
      else if (cell === opponent) opponentCount++;
      else empty++;
    }
    if (playerCount === 4) score += 100;
    else if (playerCount === 3 && empty === 1) score += 10;
    else if (playerCount === 2 && empty === 2) score += 5;
    if (opponentCount === 3 && empty === 1) score -= 100;
    else if (opponentCount === 2 && empty === 2) score -= 10;
    return score;
  }
  async put(grid) {
    await new Promise(r => setTimeout(r, 250));
    for (let col of this.getMoveOrder(grid)) {
      if (this.judge.canPut(col, grid) != -1) {
        const row = this.getNextOpenRow(grid, col);
        if (row != -1) {
          let gridCopy = this.deepCopyGrid(grid);
          gridCopy[row][col] = this.getOpponentOrder();
          if (this.judge.checkWinner(this.getOpponentOrder(), row, col, gridCopy)) return col;
        }
      }
    }
    for (let col of this.getMoveOrder(grid)) {
      if (this.judge.canPut(col, grid) != -1) {
        const row = this.getNextOpenRow(grid, col);
        if (row != -1) {
          let gridCopy = this.deepCopyGrid(grid);
          gridCopy[row][col] = this.getOrder();
          if (this.judge.checkWinner(this.getOrder(), row, col, gridCopy)) return col;
        }
      }
    }
    let putColumn = -1;
    switch (this.strategy) {
      case "MAXIMIN": putColumn = this.maximinDecision(grid, this.MAX_DEPTH); break;
      case "MINIMAX": putColumn = this.minimaxDecision(grid, this.MAX_DEPTH); break;
      case "MONTE_CARLO": putColumn = this.monteCarloDecision(grid, this.MONTE_CARLO_SIMULATIONS); break;
      default: putColumn = -1; break;
    }
    if (putColumn == -1) {
      let available = this.getAvailableColumns(grid);
      if (available.length > 0) {
        putColumn = this.prioritizeColumns(available, grid[0].length);
      } else {
        return 0;
      }
    }
    return putColumn;
  }
  minimaxDecision(grid, depth) {
    let bestScore = -Infinity, bestColumn = -1;
    for (let col of this.getMoveOrder(grid)) {
      if (this.judge.canPut(col, grid) !== -1) {
        const row = this.getNextOpenRow(grid, col);
        if (row !== -1) {
          const gridCopy = this.deepCopyGrid(grid);
          gridCopy[row][col] = this.getOrder();
          const win = this.judge.checkWinner(this.getOrder(), row, col, gridCopy);
          const score = win ? 1000000 : this.minimax(gridCopy, depth - 1, false, -Infinity, Infinity);
          if (score > bestScore) { bestScore = score; bestColumn = col; }
        }
      }
    }
    return bestColumn;
  }
  minimax(grid, depth, isMaximizing, alpha, beta) {
    if (depth === 0 || this.isFull(grid)) return this.evaluateBoard(grid);
    if (isMaximizing) {
      let maxEval = -Infinity;
      for (let col of this.getMoveOrder(grid)) {
        if (this.judge.canPut(col, grid) !== -1) {
          let row = this.getNextOpenRow(grid, col);
          if (row !== -1) {
            let gridCopy = this.deepCopyGrid(grid);
            gridCopy[row][col] = this.getOrder();
            let win = this.judge.checkWinner(this.getOrder(), row, col, gridCopy);
            let eval_ = win ? 1000000 : this.minimax(gridCopy, depth - 1, false, alpha, beta);
            maxEval = Math.max(maxEval, eval_);
            alpha = Math.max(alpha, eval_);
            if (alpha >= beta) break;
          }
        }
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for (let col of this.getMoveOrder(grid)) {
        if (this.judge.canPut(col, grid) !== -1) {
          let row = this.getNextOpenRow(grid, col);
          if (row !== -1) {
            let gridCopy = this.deepCopyGrid(grid);
            gridCopy[row][col] = this.getOpponentOrder();
            let win = this.judge.checkWinner(this.getOpponentOrder(), row, col, gridCopy);
            let eval_ = win ? -1000000 : this.minimax(gridCopy, depth - 1, true, alpha, beta);
            minEval = Math.min(minEval, eval_);
            beta = Math.min(beta, eval_);
            if (alpha >= beta) break;
          }
        }
      }
      return minEval;
    }
  }
  maximinDecision(grid, depth) {
    let bestScore = Infinity, bestColumn = -1;
    for (let col of this.getMoveOrder(grid)) {
      if (this.judge.canPut(col, grid) !== -1) {
        const row = this.getNextOpenRow(grid, col);
        if (row !== -1) {
          const gridCopy = this.deepCopyGrid(grid);
          gridCopy[row][col] = this.getOpponentOrder();
          const win = this.judge.checkWinner(this.getOpponentOrder(), row, col, gridCopy);
          const score = win ? -1000000 : this.maximin(gridCopy, depth - 1, false, -Infinity, Infinity);
          if (score < bestScore) { bestScore = score; bestColumn = col; }
        }
      }
    }
    return bestColumn;
  }
  maximin(grid, depth, isMaximizing, alpha, beta) {
    if (depth === 0 || this.isFull(grid)) return this.evaluateBoard(grid);
    if (isMaximizing) {
      let maxEval = -Infinity;
      for (let col of this.getMoveOrder(grid)) {
        if (this.judge.canPut(col, grid) !== -1) {
          let row = this.getNextOpenRow(grid, col);
          if (row !== -1) {
            let gridCopy = this.deepCopyGrid(grid);
            gridCopy[row][col] = this.getOpponentOrder();
            let win = this.judge.checkWinner(this.getOpponentOrder(), row, col, gridCopy);
            let eval_ = win ? -1000000 : this.maximin(gridCopy, depth - 1, false, alpha, beta);
            maxEval = Math.max(maxEval, eval_);
            alpha = Math.max(alpha, eval_);
            if (alpha >= beta) break;
          }
        }
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for (let col of this.getMoveOrder(grid)) {
        if (this.judge.canPut(col, grid) !== -1) {
          let row = this.getNextOpenRow(grid, col);
          if (row !== -1) {
            let gridCopy = this.deepCopyGrid(grid);
            gridCopy[row][col] = this.getOrder();
            let win = this.judge.checkWinner(this.getOrder(), row, col, gridCopy);
            let eval_ = win ? 1000000 : this.maximin(gridCopy, depth - 1, true, alpha, beta);
            minEval = Math.min(minEval, eval_);
            beta = Math.min(beta, eval_);
            if (alpha >= beta) break;
          }
        }
      }
      return minEval;
    }
  }
  monteCarloDecision(grid, simulations) {
    let availableColumns = this.getAvailableColumns(grid);
    if(availableColumns.length===0) return this.prioritizeColumns(availableColumns, grid[0].length);
    let bestColumn = -1, bestWinRate = -1.0;
    for(let col of availableColumns){
      let winCount = 0;
      for(let i=0;i<simulations;i++){
        let gridCopy = this.deepCopyGrid(grid);
        let row = this.getNextOpenRow(gridCopy, col);
        if(row === -1) continue;
        gridCopy[row][col] = this.getOrder();
        if (this.judge.checkWinner(this.getOrder(), row, col, gridCopy)) {
          winCount++; continue;
        }
        let currentPlayer = this.getOpponentOrder();
        while(true){
          let available = this.getAvailableColumns(gridCopy);
          if(available.length===0) break;
          let randomCol = available[Math.floor(Math.random()*available.length)];
          let randomRow = this.getNextOpenRow(gridCopy, randomCol);
          if(randomRow === -1) break;
          gridCopy[randomRow][randomCol] = currentPlayer;
          if(this.judge.checkWinner(currentPlayer, randomRow, randomCol, gridCopy)){
            if(currentPlayer===this.getOrder()) winCount++;
            break;
          }
          currentPlayer = (currentPlayer===0)?1:0;
        }
      }
      let winRate = winCount/simulations;
      if(winRate > bestWinRate){
        bestWinRate = winRate; bestColumn = col;
      }
    }
    return bestColumn;
  }
}
class Game {
  constructor(rows = 6, cols = 7) {
    this.rows = rows; this.cols = cols;
    this.judge = new Judge(rows, cols);
    this.board = new Board(rows, cols, "game-board");
    this.recorder = new Recorder("log-user", "log-com");
    this.players = [
      new Man("あなた", 0, this.board),
      new Com("THEORIST", 1, this.judge, "MONTE_CARLO") // 策略: "MINIMAX" "MAXIMIN"も可
    ];
    this.turn = 0; this.running = false;
    this.banner = document.getElementById("winner-banner");
    document.getElementById("controls").innerHTML = `<button id="start-btn">スタート</button>`;
    document.getElementById("start-btn").onclick = () => this.start();
    this.renderAvatars(0);
  }
  renderAvatars(activeOrder) {
    const sides = [
      {id:"avatar-user", icon:"*'ω'*", name:"あなた", color:"user"},
      {id:"avatar-com",  icon:" ", name:"COM",   color:"com"}
    ];
    for(const side of sides) {
      const area = document.getElementById(side.id);
      area.innerHTML =
      `<div class="avatar ${side.color} ${activeOrder=== (side.id === "avatar-user" ? 0 : 1) ? "active" : ""}">
        <div class="avatar-icon">${side.icon}</div>
        <div class="avatar-name">${side.name}</div>
      </div>`;
    }
  }
  showWinnerBanner(name, color) {
    const el = this.banner;
    el.innerHTML = `<span style="font-size:2.5em;"> </span> <span style="color:${color==='red'?'#d00':'#074fb7'};">${name}</span>の勝ち！ <span style="font-size:2.1em;"> </span>`;
    el.style.display = "block";
    setTimeout(()=>el.style.boxShadow="0 0 80px #fc0e", 700);
  }
  hideWinnerBanner() {
    this.banner.style.display = "none";
  }
  async start() {
    this.board.reset(); this.recorder.clear(); this.turn = 0; this.running = true;
    this.hideWinnerBanner();
    this.renderAvatars(0);
    while (this.running) {
      const player = this.players[this.turn % 2];
      const isHuman = (player instanceof Man);
      this.board.enableColBtns(isHuman);
      this.renderAvatars(player.getOrder());
      const grid = this.board.getGrid();
      const col = await player.put(grid);
      this.board.enableColBtns(false);
      const row = this.judge.canPut(col, grid);
      if (row === -1) { alert("そこには置けません！"); continue; }
      await this.board.update(row, col, player.getColor());
      this.recorder.record(player, col);
      if (this.judge.checkWinner(player.getOrder(), row, col, this.board.getGrid())) {
        this.renderAvatars(player.getOrder());
        setTimeout(()=>{
          this.showWinnerBanner(player.getName(), player.getColor());
        }, 170);
        this.running = false; return;
      }
      if (this.isFull(this.board.getGrid())) {
        setTimeout(()=>{
          this.showWinnerBanner("（引き分け）", "#333");
        },200);
        this.running = false; return;
      }
      this.turn++;
    }
  }
  isFull(grid) { return grid[0].every(cell => cell !== -1); }
}
window.onload = () => { new Game(); };
</script>
</body>
</html>
